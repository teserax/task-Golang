// Описание задачи
// Имитируется работа кассира. С клавиатуры вводятся
// стоимость покупки и сумма денег, полученных от
// покупателя. Кассир рассчитывает сумму сдачи, которую
// он должен вернуть покупателю. Сумма сдачи должна
// быть сформирована из минимального количества
// банкнот.

package main

import "fmt"

// данные кассы одного номинала
type banknota struct {
	Value int // номинал
	Count int // количество в кассе
}

func main() {
	// ввод цены не буду писать
	// просто возьму тестовые данные
	// сумма к оплате
	totalSumma := 1100
	// сумма от покупателя
	fromBuyerSumma := 2000

	// формируем кассу

	cassa := []banknota{
		{
			Value: 500,
			Count: 1,
		}, {
			Value: 200,
			Count: 1,
		}, {
			Value: 100,
			Count: 0,
		}, {
			Value: 50,
			Count: 1,
		}, {
			Value: 20,
			Count: 1,
		}, {
			Value: 10,
			Count: 20,
		},
	}

	// считаем сколько надо дать сдачи
	forRest := fromBuyerSumma - totalSumma
	fmt.Println("Надо дать сдачи ", forRest)

	// если сумма отрицательна то выводим сообщение что деньги не все дал покупатель
	if forRest < 0 {
		fmt.Println("Не все деньги дат покупатель, еще должен дать ", totalSumma-fromBuyerSumma, ". Программа закрывается.")
		return
	}
	// если остаток равен 0, то сдачи давать не нужно
	if forRest == 0 {
		fmt.Println("Покупатель дал точную сумму. Программа закрывается.")
	}

	var (
		// надо подумать как хранить результат сдачи, нам надо знать какие банкноты и сколько дать в сдачи.
		// Тоже можно использовать слайс от структуры banknota
		rest []banknota
		// также не надо забывать что для сдачи в кассе может денег не хватать,
		//для этого сохранить какая сдача у нас сформировалась
		restSumma int
	)

	// мне нужно менять сумму для остатка, так как я должен понимать
	// сколько еще осталось дать сдачи, после того как я выбрал какую то купюру
	// сначала  эта переменная  равна полной сдаче
	tempTotalRest := forRest

	// у нас в кассе банкноты сохранены от большей к меньшей.
	// То есть мы спокойно обходим от большей к меньшей их по циклу.
	// цикл прекращается если у нас сумма для возврата собрана или кончился обход денег в кассе

	for i := 0; i < len(cassa) && tempTotalRest > 0; i++ {
		// для кажлой банкноты в кассе мы определяем сколько надо дать банкнот для формирования сдачи
		// при этом надо учитывать а сколько у нас есть в кассе банкнот

		// cassa[i] это структура текушей банкноты.

		// считаем сколько надо дать банкнот в сдачи (в цикле подсчет будет от большей к меньшей)
		n := tempTotalRest / cassa[i].Value

		fmt.Println("банкнот ", cassa[i].Value, "надо дать ", n)

		// проверяем если у нас есть такое количество банкнот в кассе, если нет, то дает то что есть
		if cassa[i].Count < n {
			n = cassa[i].Count
			fmt.Println("В кассе банкнот ", cassa[i].Value, "не хватает, поэтому даем ", n)

		}

		// запоминаем какая купюра и сколько надо дать в слайс купюр сдачь
		rest = append(rest, banknota{
			Value: cassa[i].Value,
			Count: n,
		})

		// определяем сколько осталась сумма сдачи
		tempTotalRest -= n * cassa[i].Value

		// добавляем в сумму сдач полученные значения банкнот и их количество
		restSumma += n * cassa[i].Value

		// еще сюда можно отнимать из касы выданные купюры
		// .....
		// .....
		fmt.Println("Осталось из сдачь собрать еще", tempTotalRest)
	}

	// проверяем если полученная сумма сдачи равна той которую надо было дать. Если не равно, то у нас не хватило денег в кассе.
	if restSumma < forRest {
		fmt.Println("Денег в кассе не хватило. Eсть только сумма: ", restSumma)
	}

	fmt.Printf("Сдачи собраны %d. Банкноты для выдачи: %#v\n", restSumma, rest)
}
